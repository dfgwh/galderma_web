<!DOCTYPE html>
<html lang = "en">
    <head>
        <title>galderma</title>

		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		
        <link type="text/css" rel="stylesheet" href="main.css">
        
        <style>
			a {
				color: #f00;
			}
			.no-pointer-events {
				pointer-events: none;
			}
			.control-disabled {
				color: #888;
				text-decoration: line-through;
			}
		</style>
    </head>
    <body>
		<script src = "three.js"></script>
        <script src = "js/main.js"></script>

		<div class = "container">
			<div id = "openPackageButton" type = "button">
				<div class = "blockInButton">
					<img src="images/open_icon.svg">
					<span>Open Package</span>
				</div>
			</div>
			<div id = "backButton" type = "button">
				<div class = "blockInButton">
					<img src="images/Vector4.svg">
					<span>Back</span>
				</div>
			</div>
		</div>

		<script type = "module">

			import { OrbitControls } from './three/examples/jsm/controls/OrbitControls.js'
        	import { FBXLoader } from './three/examples/jsm/loaders/FBXLoader.js'
			import { GLTFLoader } from './three/examples/jsm/loaders/GLTFLoader.js';
			import { TWEEN } from './three/examples/jsm/libs/tween.module.min.js'
			//import { FBXLoader } from 'FBXLoader.js';
			import { EffectComposer } from './three/examples/jsm/postprocessing/EffectComposer.js';
			import { RenderPass } from './three/examples/jsm/postprocessing/RenderPass.js';
			import { BokehPass } from './three/examples/jsm/postprocessing/BokehPass.js';
			import { Reflector } from './three/examples/jsm/objects/Reflector.js';
			import {
    CSS2DRenderer,
    CSS2DObject
} from './three/examples/jsm/renderers/CSS2DRenderer.js';
			
			import { BokehShader, BokehDepthShader } from './three/examples/jsm/shaders/BokehShader2.js';

            let scene, renderer, camera, stats;
			let model, skeleton, mixer, clock;
			let orbitcontrol, main_action;
			const crossFadeControls = [];

			let idleAction, walkAction, runAction;
			let idleWeight, walkWeight, runWeight;
			let actions, settings;
			let isOpenMainModel = false;

			let singleStepMode = false;
			let sizeOfNextStep = 0;

			let width = window.innerWidth;
			let height = window.innerHeight;

			let materialDepth;
			//const postprocessing = {};
			let distance = 100;
			let effectController;

			const postprocessing = { enabled: true };

			const shaderSettings = {
				rings: 3,
				samples: 4
			};

			const mouse = new THREE.Vector2();
			const raycaster = new THREE.Raycaster();
			const target = new THREE.Vector3( 0, 20, - 50 );
			const planes = [];
			const leaves = 100;

			init();
			let mainmodel, ingectionSyringeModel, needle1Model, needle2Model;

			function init() {

				const container = document.querySelector( '.container' );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 1, 4, - 3 );
				camera.lookAt( 0, 1, 0 );

				clock = new THREE.Clock();

				scene = new THREE.Scene();
				scene.background = new THREE.Color("rgb(133,202,237)");
				scene.fog = new THREE.Fog("rgb(133,202,237)", 20, 80 );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				container.appendChild( renderer.domElement );

				//OrbitControls
				orbitcontrol = new OrbitControls(camera, renderer.domElement);
				orbitcontrol.update();
				orbitcontrol.maxPolarAngle = Math.PI / 2.5;
				//orbitcontrol.minPolarAngle = Math.PI / 3;
				orbitcontrol.enablePan = false;
				orbitcontrol.dampingFactor = 0.1;
				orbitcontrol.enableDamping = true;
				orbitcontrol.minDistance = 20;
				orbitcontrol.maxDistance = 55;

				const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				hemiLight.position.set( 0, 20, 0 );
				scene.add( hemiLight );
				const dirLight = new THREE.DirectionalLight( 0xffffff );
				dirLight.position.set( - 3, 10, - 10 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.top = 2;
				dirLight.shadow.camera.bottom = - 2;
				dirLight.shadow.camera.left = - 2;
				dirLight.shadow.camera.right = 2;
				dirLight.shadow.camera.near = 0.1;
				dirLight.shadow.camera.far = 40;
				scene.add( dirLight );

				// ground
				const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
				mesh.rotation.x = - Math.PI / 2;
				mesh.position.y = -20;
				mesh.receiveShadow = true;
				scene.add( mesh );

				const depthShader = BokehDepthShader;

				materialDepth = new THREE.ShaderMaterial( {
					uniforms: depthShader.uniforms,
					vertexShader: depthShader.vertexShader,
					fragmentShader: depthShader.fragmentShader
				} );

				materialDepth.uniforms[ 'mNear' ].value = camera.near;
				materialDepth.uniforms[ 'mFar' ].value = camera.far;

				function dumpObject(obj, lines = [], isLast = true, prefix = '') {
					const localPrefix = isLast ? '└─' : '├─';
					lines.push(`${prefix}${prefix ? localPrefix : ''}${obj.name || '*no-name*'} [${obj.type}]`);
					const newPrefix = prefix + (isLast ? '  ' : '│ ');
					const lastNdx = obj.children.length - 1;
					obj.children.forEach((child, ndx) => {
						const isLast = ndx === lastNdx;
						dumpObject(child, lines, isLast, newPrefix);
					});
					return lines;
				}
				
				const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(2048)
				const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget)
				scene.add(cubeCamera)

				const glassMaterial = new THREE.MeshPhysicalMaterial({
					metalness: 1.0,
					roughness: 0.2,
					envMap: cubeRenderTarget.texture,
					refractionRatio: 0.95,
					transparent: true,
					opacity: 0.4,
					transmission: 0.1,
					side: THREE.FrontSide,
					clearcoat: 1.0,
					clearcoatRoughness: 0.39
				})

				const formMaterial = new THREE.MeshPhysicalMaterial({
					metalness: 1.0,
					roughness: 0.2,
					envMap: cubeRenderTarget.texture,
					refractionRatio: 0.95,
					transparent: true,
					opacity: 0.2,
					transmission: 0.1,
					side: THREE.FrontSide,
					clearcoat: 1.0,
					clearcoatRoughness: 0.39
				})

				const fbxLoader = new FBXLoader()
				model = fbxLoader.load(
					'models/Restylane.fbx',
					(root) => {
						root.scale.set(60, 60, 60)
						scene.add(root);
						console.log(dumpObject(root).join('\n'));
						mainmodel = root;

						skeleton = new THREE.SkeletonHelper( root );
						skeleton.visible = false;
						scene.add( skeleton );

						const clips = root.animations;
						mixer = new THREE.AnimationMixer( root );
						console.log(clips);


						main_action = mixer.clipAction(clips[0]);

						root.children.forEach((child) => {
							console.log(child.name, "    ", child.animations);
							if (child.name == "Box" /*|| child.name == "Form"*/)
							{
								let box = child;
								box.visible = false;
							}

						});

						root.traverse(function(child){
                        	if (child.isMesh){
                            //console.log(child);
                    
								if (child.name == "InjectorGlass" || child.name == "NeedleCap" || child.name == "NeedleCase")
								{
									child.material = glassMaterial;
								}
								if (child.name == "Form")
								{
									child.material = formMaterial;
									child.visible = false;
								}
							}

                            // roughnessMipmapper.generateMipmaps(child.material);
                        //}
                    });

						let testIngector = root.children;
						console.log(testIngector);
						//testIngector.position.set(-10, 0, 0);
						//ingectionSyringeModel;
						//needle1Model;
						//needle2Model;

						update();
					},
					(xhr) => {
						console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
					},
					(error) => {
						console.log(error)
					}
				);

				const gltfLoader = new GLTFLoader();
				/*
				gltfLoader.load('models/Stork.glb', (gltf) => {
					const root = gltf.scene;
					scene.add(root);
					console.log(dumpObject(root).join('\n'));
					mainmodel = root;
					root.scale.set(.1, .1, .1);
					root.rotation.set(0,0,0);

					skeleton = new THREE.SkeletonHelper( root );
					skeleton.visible = false;
					scene.add( skeleton );

					const clips = gltf.animations;
					mixer = new THREE.AnimationMixer( root );
					console.log(clips[0]);


					main_action = mixer.clipAction(clips[0]);

					update();
				});*/

				gltfLoader.load('models/Flamingo.glb', (gltf) => {
					const root = gltf.scene;
					scene.add(root);
					console.log(dumpObject(root).join('\n'));
					ingectionSyringeModel = root;
					root.scale.set(.1, .1, .1);
					root.rotation.set(0,0,0);
					root.position.set(-10,0,0);
					root.visible = false;
				});
				
				gltfLoader.load('models/Horse.glb', (gltf) => {
					const root = gltf.scene;
					scene.add(root);
					console.log(dumpObject(root).join('\n'));
					needle1Model = root;
					root.scale.set(.05, .05, .05);
					root.rotation.set(0,0,0);
					root.position.set(0,0,0);
					root.visible = false;
				});

				gltfLoader.load('models/Parrot.glb', (gltf) => {
					const root = gltf.scene;
					scene.add(root);
					console.log(dumpObject(root).join('\n'));
					needle2Model = root;
					root.scale.set(.1, .1, .1);
					root.rotation.set(0,0,0);
					root.position.set(10,0,0);
					root.visible = false;
				});

				window.addEventListener('resize', onWindowResize, false)
				
				function onWindowResize() {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					renderer.setSize(window.innerWidth, window.innerHeight)
				}

				function update()
				{
					mixer.update(clock.getDelta());
					requestAnimationFrame(update)
				}

				function animate() {
					//model.rotation.y += 0.1;
					requestAnimationFrame(animate)
					orbitcontrol.update();
					TWEEN.update()
					renderer.render(scene, camera)
				}
				animate();

				//initPostprocessing();
/*

				effectController = {
					enabled: true,
					jsDepthCalculation: true,
					shaderFocus: false,

					fstop: 2.2,
					maxblur: 1.0,

					showFocus: false,
					focalDepth: 2.8,
					manualdof: false,
					vignetting: false,
					depthblur: false,

					threshold: 0.5,
					gain: 2.0,
					bias: 0.5,
					fringe: 0.7,

					focalLength: 35,
					noise: true,
					pentagon: false,

					dithering: 0.0001
				};

				const matChanger = function () {

					for ( const e in effectController ) {

						if ( e in postprocessing.bokeh_uniforms ) {

							postprocessing.bokeh_uniforms[ e ].value = effectController[ e ];

						}

					}

					postprocessing.enabled = effectController.enabled;
					postprocessing.bokeh_uniforms[ 'znear' ].value = camera.near;
					postprocessing.bokeh_uniforms[ 'zfar' ].value = camera.far;
					camera.setFocalLength( effectController.focalLength );

				};
				matChanger();*/
				//renderer.autoClear = false;

				//stats = new Stats();
				//container.appendChild( stats.dom );

				//container.style.touchAction = 'none';
				//container.addEventListener( 'pointermove', onPointerMove );

				//window.addEventListener( 'resize', onWindowResize );

				/*const effectController = {

					focus: 10.0,
					aperture: 5,
					maxblur: 0.01

				};

				const matChanger = function ( ) {

					postprocessing.bokeh.uniforms[ "focus" ].value = effectController.focus;
					postprocessing.bokeh.uniforms[ "aperture" ].value = effectController.aperture * 0.00001;
					postprocessing.bokeh.uniforms[ "maxblur" ].value = effectController.maxblur;

				};*/

			}

			function resizeRendererToDisplaySize(renderer) {
				const canvas = renderer.domElement;
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				const needResize = canvas.width !== width || canvas.height !== height;
				if (needResize) {
				renderer.setSize(width, height, false);
				}
				return needResize;
			}
			let isTime = false;
			let tempTime;
			let timedelta = 0;
			let isRebase = false;
			function render(time) {
				time *= 0.0002;  // convert to seconds
				if (isRebase)
				{
					isRebase = false;
					isTime = false;
					timedelta = 0;
					return;
				}
				//console.log(time);
				/*if (resizeRendererToDisplaySize(renderer)) {
					const canvas = renderer.domElement;
					camera.aspect = canvas.clientWidth / canvas.clientHeight;
					camera.updateProjectionMatrix();
				}*/
				//console.log(time);
				if (!isOpenMainModel && mainmodel) {
					mainmodel.rotation.y = time;
				} 
				else if (isOpenMainModel){
					if (!isTime && timedelta < 1)
					{
						isTime = true;
						tempTime = time;
					}

					if (isTime && timedelta > 1)
					{
						mainmodel.visible = false;
						console.log("enable")
						isTime = false;
						document.getElementById("backButton").style.display = "block";
						ingectionSyringeModel.visible = true;
						needle1Model.visible = true;
						needle2Model.visible = true;
					}

					if (mainmodel.visible) {
						mainmodel.position.z = timedelta*10;
						timedelta = time-tempTime;
					}
				}
				
				renderer.render(scene, camera);
				
				requestAnimationFrame(render);
			}
			requestAnimationFrame(render);

			function InitUIClick()
			{
				let obj = document.getElementById("openPackageButton");
				let backButton = document.getElementById("backButton");

				obj.onclick = function(){
					isOpenMainModel = true;
					mainmodel.rotation.set(0,0,0);
					mainmodel.position.set(0,0,0);
					camera.position.set( 1, 4, - 3 );
					orbitcontrol.enabled = false;
					main_action.play();
					obj.style.display = "none";
					//backButton.style.display = "block";
				}

				backButton.onclick = function(){
					isRebase = true;
					isOpenMainModel = false;
					mainmodel.rotation.set(0,0,0);
					mainmodel.position.set(0,0,0);
					camera.position.set( 1, 4, - 3 );
					orbitcontrol.enabled = true;
					main_action.stop();
					mainmodel.visible = true;
					backButton.style.display = "none";
					obj.style.display = "block";
					ingectionSyringeModel.visible = false;
						needle1Model.visible = false;
						needle2Model.visible = false;
						requestAnimationFrame(render);
				}
			}

			function initPostprocessing() {
				postprocessing.scene = new THREE.Scene();
				postprocessing.camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 10000, 10000 );
				postprocessing.camera.position.z = 100;
				postprocessing.scene.add( postprocessing.camera );
				const pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };
				postprocessing.rtTextureDepth = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, pars );
				postprocessing.rtTextureColor = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, pars );
				const bokeh_shader = BokehShader;
				postprocessing.bokeh_uniforms = THREE.UniformsUtils.clone( bokeh_shader.uniforms );
				postprocessing.bokeh_uniforms[ 'tColor' ].value = postprocessing.rtTextureColor.texture;
				postprocessing.bokeh_uniforms[ 'tDepth' ].value = postprocessing.rtTextureDepth.texture;
				postprocessing.bokeh_uniforms[ 'textureWidth' ].value = window.innerWidth;
				postprocessing.bokeh_uniforms[ 'textureHeight' ].value = window.innerHeight;
				postprocessing.materialBokeh = new THREE.ShaderMaterial( {
					uniforms: postprocessing.bokeh_uniforms,
					vertexShader: bokeh_shader.vertexShader,
					fragmentShader: bokeh_shader.fragmentShader,
					defines: {
						RINGS: shaderSettings.rings,
						SAMPLES: shaderSettings.samples
					}
			} );

postprocessing.quad = new THREE.Mesh( new THREE.PlaneGeometry( window.innerWidth, window.innerHeight ), postprocessing.materialBokeh );
postprocessing.quad.position.z = - 500;
postprocessing.scene.add( postprocessing.quad );

}
			//initPostprocessing();
			InitUIClick();
			
        </script>
    </body>
</html>