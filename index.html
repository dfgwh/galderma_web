<!DOCTYPE html>
<html lang = "en">
    <head>
        <title>galderma</title>

		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		
        <link type="text/css" rel="stylesheet" href="main.css">
        
        <style>
			a {
				color: #f00;
			}
			.no-pointer-events {
				pointer-events: none;
			}
			.control-disabled {
				color: #888;
				text-decoration: line-through;
			}
		</style>
    </head>
    <body>
		<script src = "three.js"></script>
        <script src = "js/main.js"></script>

		<div class = "container">
			<div id = "openPackageButton" type = "button">
				<div class = "blockInButton">
					<img src="images/open_icon.svg">
					<span>Open Package</span>
				</div>
			</div>
			<div id = "backButton" type = "button">
				<div class = "blockInButton">
					<img src="images/Vector4.svg">
					<span>Back</span>
				</div>
			</div>
			<div id = "prepareButton" type = "button">
				<div class = "blockInButton">
					<img src="images/prepare_icon.png">
					<span>Prepare</span>
				</div>
			</div>
		</div>

		<script type = "module">

			import { OrbitControls } from './three/examples/jsm/controls/OrbitControls.js'
        	import { FBXLoader } from './three/examples/jsm/loaders/FBXLoader.js'
			import { GLTFLoader } from './three/examples/jsm/loaders/GLTFLoader.js';
			import { TWEEN } from './three/examples/jsm/libs/tween.module.min.js'
			//import { FBXLoader } from 'FBXLoader.js';
			import { EffectComposer } from './three/examples/jsm/postprocessing/EffectComposer.js';
			import { RenderPass } from './three/examples/jsm/postprocessing/RenderPass.js';
			import { BokehPass } from './three/examples/jsm/postprocessing/BokehPass.js';
			import { Reflector } from './three/examples/jsm/objects/Reflector.js';
			import { CSS2DRenderer, CSS2DObject } from './three/examples/jsm/renderers/CSS2DRenderer.js';
			
			import { BokehShader, BokehDepthShader } from './three/examples/jsm/shaders/BokehShader2.js';

            let scene, renderer, camera, stats;
			let model, skeleton, mixer, clock;
			let orbitcontrol, box_action, manual_action;
			let isBoxAnimate = false, isManualAnimate = false;
			const crossFadeControls = [];

			let idleAction, walkAction, runAction;
			let idleWeight, walkWeight, runWeight;
			let actions, settings;
			let isOpenMainModel = false;
			let isAnimate = false;

			let singleStepMode = false;
			let sizeOfNextStep = 0;

			let width = window.innerWidth;
			let height = window.innerHeight;

			let materialDepth;
			//const postprocessing = {};
			let distance = 100;
			let effectController;

			const postprocessing = { enabled: true };

			const shaderSettings = {
				rings: 3,
				samples: 4
			};

			const mouse = new THREE.Vector2();
			const raycaster = new THREE.Raycaster();
			const target = new THREE.Vector3( 0, 20, - 50 );
			const planes = [];
			const leaves = 100;
			const container = document.querySelector( '.container' );

			init();
			let mainmodel, ingectionSyringeModel, needle1Model, needle2Model, box, form, manual, formcup;
			let timer_delta;

			function init() {
				createScene();

				const depthShader = BokehDepthShader;

				materialDepth = new THREE.ShaderMaterial( {
					uniforms: depthShader.uniforms,
					vertexShader: depthShader.vertexShader,
					fragmentShader: depthShader.fragmentShader
				} );

				materialDepth.uniforms[ 'mNear' ].value = camera.near;
				materialDepth.uniforms[ 'mFar' ].value = camera.far;


				
				const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(2048)
				const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget)
				scene.add(cubeCamera)

				const glassMaterial = new THREE.MeshPhysicalMaterial({
					metalness: 1.0,
					roughness: 0.2,
					envMap: cubeRenderTarget.texture,
					refractionRatio: 0.95,
					transparent: true,
					opacity: 0.4,
					transmission: 0.1,
					side: THREE.FrontSide,
					clearcoat: 1.0,
					clearcoatRoughness: 0.39
				})

				const formMaterial = new THREE.MeshPhysicalMaterial({
					metalness: 1.0,
					roughness: 0.2,
					envMap: cubeRenderTarget.texture,
					refractionRatio: 0.95,
					transparent: true,
					opacity: 0.2,
					transmission: 0.1,
					side: THREE.FrontSide,
					clearcoat: 1.0,
					clearcoatRoughness: 0.39
				})

				const fbxLoader = new FBXLoader()
				model = fbxLoader.load(
					'models/Restlane.fbx',
					(root) => {
						root.scale.set(60, 60, 60)
						scene.add(root);
						console.log(dumpObject(root).join('\n'));
						mainmodel = root;

						skeleton = new THREE.SkeletonHelper( root );
						skeleton.visible = false;
						scene.add( skeleton );

						const clips = root.animations;
						mixer = new THREE.AnimationMixer( root );
						console.log(clips);


						box_action = mixer.clipAction(clips[3]);
						manual_action = mixer.clipAction(clips[1]);

						root.traverse(function(child){
							//console.log(child.name, "    ", child.animations);
							if (child.name == "Box" /*|| child.name == "Form"*/)
							{
								box = child;
								//box.visible = false;
							}


                        	if (child.isMesh){

								if (child.name == "Form")
								{
									form = child;
									child.material = formMaterial;
									//child.visible = false;
								}
								if (child.name == "manual")
								{
									manual = child;
								}

								if (child.name == "FormCap")
								{
									formcup = child;
								}
                    
								if (child.name == "InjectorGlass" || child.name == "NeedleCap" || child.name == "NeedleCase" || child.name == "NeedleCase2Glass")
								{
									child.material = glassMaterial;

									const annotationDiv = document.createElement('div');
									annotationDiv.className = 'annotationLabel';
									annotationDiv.innerHTML = '25';
									const annotationLabel = new CSS2DObject(annotationDiv);
									annotationLabel.position.copy(child.position);
									root.add(annotationLabel);

										const annotationTextDiv = document.createElement('div');
										annotationTextDiv.className = 'annotationDescription';
										annotationTextDiv.innerHTML = 'child.userData.title';
	
											annotationTextDiv.innerHTML += '<p>' + 'test' + '</p>';
										
										annotationDiv.appendChild(annotationTextDiv);	
								}
							}
                    	});

						//ingectionSyringeModel;
						//needle1Model;
						//needle2Model;

						update();
					},
					(xhr) => {
						console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
					},
					(error) => {
						console.log(error)
					}
				);

				const gltfLoader = new GLTFLoader();

				gltfLoader.load('models/Flamingo.glb', (gltf) => {
					const root = gltf.scene;
					scene.add(root);
					console.log(dumpObject(root).join('\n'));
					ingectionSyringeModel = root;
					root.scale.set(.1, .1, .1);
					root.rotation.set(0,0,0);
					root.position.set(-10,0,0);
					root.visible = false;
				});
				
				gltfLoader.load('models/Horse.glb', (gltf) => {
					const root = gltf.scene;
					scene.add(root);
					console.log(dumpObject(root).join('\n'));
					needle1Model = root;
					root.scale.set(.05, .05, .05);
					root.rotation.set(0,0,0);
					root.position.set(0,0,0);
					root.visible = false;
				});

				gltfLoader.load('models/Parrot.glb', (gltf) => {
					const root = gltf.scene;
					scene.add(root);
					console.log(dumpObject(root).join('\n'));
					needle2Model = root;
					root.scale.set(.1, .1, .1);
					root.rotation.set(0,0,0);
					root.position.set(10,0,0);
					root.visible = false;
				});

				window.addEventListener('resize', onWindowResize, false)
				
				function onWindowResize() {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					renderer.setSize(window.innerWidth, window.innerHeight)
				}

				function update()
				{
					mixer.update(clock.getDelta());
					requestAnimationFrame(update)
				}

				function animate() {
					//model.rotation.y += 0.1;
					requestAnimationFrame(animate)
					orbitcontrol.update();
					TWEEN.update()
					renderer.render(scene, camera)
				}
				animate();

			}

			// created base configurations for scene
			function createScene()
			{
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 1, 4, - 3 );
				camera.lookAt( 0, 1, 0 );

				document.addEventListener('mousedown', onDocumentMouseDown, false);

				clock = new THREE.Clock();

				scene = new THREE.Scene();
				scene.background = new THREE.Color("rgb(133,202,237)");
				scene.fog = new THREE.Fog("rgb(133,202,237)", 20, 80 );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				container.appendChild( renderer.domElement );

				//OrbitControls
				orbitcontrol = new OrbitControls(camera, renderer.domElement);
				orbitcontrol.update();
				orbitcontrol.maxPolarAngle = Math.PI / 2.5;
				//orbitcontrol.minPolarAngle = Math.PI / 3;
				orbitcontrol.enablePan = false;
				orbitcontrol.dampingFactor = 0.1;
				orbitcontrol.enableDamping = true;
				orbitcontrol.minDistance = 20;
				orbitcontrol.maxDistance = 55;

				const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				hemiLight.position.set( 0, 20, 0 );
				scene.add( hemiLight );
				const dirLight = new THREE.DirectionalLight( 0xffffff );
				dirLight.position.set( - 3, 10, - 10 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.top = 2;
				dirLight.shadow.camera.bottom = - 2;
				dirLight.shadow.camera.left = - 2;
				dirLight.shadow.camera.right = 2;
				dirLight.shadow.camera.near = 0.1;
				dirLight.shadow.camera.far = 40;
				scene.add( dirLight );

				// ground
				const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
				mesh.rotation.x = - Math.PI / 2;
				mesh.position.y = -20;
				mesh.receiveShadow = true;
				scene.add( mesh );
			}

			// write object structer to console
			function dumpObject(obj, lines = [], isLast = true, prefix = '') {
					const localPrefix = isLast ? '└─' : '├─';
					lines.push(`${prefix}${prefix ? localPrefix : ''}${obj.name || '*no-name*'} [${obj.type}]`);
					const newPrefix = prefix + (isLast ? '  ' : '│ ');
					const lastNdx = obj.children.length - 1;
					obj.children.forEach((child, ndx) => {
						const isLast = ndx === lastNdx;
						dumpObject(child, lines, isLast, newPrefix);
					});
					return lines;
			}

			function startBoxAnimationAction()
			{
				timer_delta = 6.6;
				box_action.play();
				isAnimate = true;
				isBoxAnimate = true;

			}

			function endBoxAnimationAction()
			{
				box_action.stop();
				isBoxAnimate = false;
				box.visible = false;
				startManualAction();
			}

			function startManualAction()
			{
				manual_action.reset()
				manual_action.timeScale = 1;
    			manual_action.setLoop(THREE.LoopOnce);
				manual_action.clampWhenFinished = true;
				timer_delta = 2.4;
				manual_action.play();
				isAnimate = true;
				isManualAnimate = true;

			}

			function endManualAction()
			{
				manual_action.stop();
				isManualAnimate = false;
				manual.visible = false;
				form.visible = false;
				formcup.visible = false;
				startSecondStep();
			}

			function startReversManualActions()
			{
				manual_action.paused = false;
				manual_action.timeScale = -5;
				manual_action.setLoop(THREE.LoopOnce);  
				timer_delta = 2.4;    
				manual_action.play();
				isAnimate = true;
				isManualAnimate = true;
				formcup.visible = true;
				form.visible = true;
				manual.visible = true;
			}

			function endReverseManualActions()
			{

			}

			function startSecondStep()
			{
				document.getElementById("backButton").style.display = "block";
			}

			function startIngectorAction()
			{

			}

			function resizeRendererToDisplaySize(renderer) {
				const canvas = renderer.domElement;
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				const needResize = canvas.width !== width || canvas.height !== height;
				if (needResize) {
				renderer.setSize(width, height, false);
				}
				return needResize;
			}


			let isTime = false;
			let tempTime;
			let timedelta = 0;
			let isRebase = false;
			function render(time) {
				time *= 0.001;  // convert to seconds
				if (isAnimate && !isTime)
				{
					isTime = true;
					tempTime = time;
					console.log("start", time, " ", timer_delta);
				}

				if (isTime)
				{
					timedelta = (time) - tempTime;
					//console.log (timedelta);

					if (isManualAnimate)
					{
						form.position.z += (isRebase?-1:1)*0.01;
					}
				}
				timedelta = (time)- tempTime;

				if (timedelta > timer_delta)
				{
					if (isAnimate)
					{
						isAnimate = false;
						isTime = false;
						//console.log(mixer.animate.name);
						if (isBoxAnimate)
						{
								endBoxAnimationAction();
								console.log("end box");
						}	
						else if (isManualAnimate)
						{
							if (isRebase)
							{
								endReverseManualActions();
							}
							else{
								endManualAction();
							}

							console.log("end manual");
						}
					}
				}

		/*		if (isRebase)
				{
					isRebase = false;
					isTime = false;
					timedelta = 0;
					return;
				}
				//console.log(time);
				/*if (resizeRendererToDisplaySize(renderer)) {
					const canvas = renderer.domElement;
					camera.aspect = canvas.clientWidth / canvas.clientHeight;
					camera.updateProjectionMatrix();
				}*/
				//console.log(time);
		/*		if (!isOpenMainModel && mainmodel) {
					mainmodel.rotation.y = time;
				} 
				else if (isOpenMainModel){
					if (!isTime && timedelta < 4)
					{
						isTime = true;
						tempTime = time;
					}

					if (isTime && timedelta > 4)
					{
						mainmodel.visible = false;
						console.log("enable")
						isTime = false;
						document.getElementById("backButton").style.display = "block";
						ingectionSyringeModel.visible = true;
						needle1Model.visible = true;
						needle2Model.visible = true;
					}

					if (mainmodel.visible) {
						//mainmodel.position.z = timedelta*10;
						timedelta = time-tempTime;
					}
				}
				*/
				renderer.render(scene, camera);
				
				requestAnimationFrame(render);
			}
			requestAnimationFrame(render);

			
			function InitUIClick()
			{
				let obj = document.getElementById("openPackageButton");
				let backButton = document.getElementById("backButton");

				obj.onclick = function(){
					isOpenMainModel = true;
					mainmodel.rotation.set(0,0,0);
					mainmodel.position.set(0,0,0);
					camera.position.set( 1, 4, - 3 );
					orbitcontrol.enabled = false;
					startBoxAnimationAction();
					obj.style.display = "none";
					//backButton.style.display = "block";
				}

				backButton.onclick = function(){
					isRebase = true;
					/*isOpenMainModel = false;
					mainmodel.rotation.set(0,0,0);
					mainmodel.position.set(0,0,0);
					camera.position.set( 1, 4, - 3 );
					orbitcontrol.enabled = true;
					//main_action.stop();
					mainmodel.visible = true;
					backButton.style.display = "none";
					obj.style.display = "block";
					ingectionSyringeModel.visible = false;
						needle1Model.visible = false;
						needle2Model.visible = false;
						requestAnimationFrame(render);*/
					startReversManualActions();
				}
			}

			function onDocumentMouseDown(e)
			{
				e.preventDefault();
				var mouseVector = new THREE.Vector3();

				mouseVector.x = 2 * (e.clientX / renderer.domElement.clientWidth) - 1;
				mouseVector.y = 1 - 2 * ( e.clientY / renderer.domElement.clientHeight );
				var raycaster = projector.pickingRay( mouseVector.clone(), camera );
				var intersects = raycaster.intersectObject( TARGET );
				for( var i = 0; i < intersects.length; i++ ) {
					var intersection = intersects[ i ],
					obj = intersection.object;
					console.log("Intersected object", obj.name);
				}
			}

			function initPostprocessing() {
				postprocessing.scene = new THREE.Scene();
				postprocessing.camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 10000, 10000 );
				postprocessing.camera.position.z = 100;
				postprocessing.scene.add( postprocessing.camera );
				const pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };
				postprocessing.rtTextureDepth = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, pars );
				postprocessing.rtTextureColor = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, pars );
				const bokeh_shader = BokehShader;
				postprocessing.bokeh_uniforms = THREE.UniformsUtils.clone( bokeh_shader.uniforms );
				postprocessing.bokeh_uniforms[ 'tColor' ].value = postprocessing.rtTextureColor.texture;
				postprocessing.bokeh_uniforms[ 'tDepth' ].value = postprocessing.rtTextureDepth.texture;
				postprocessing.bokeh_uniforms[ 'textureWidth' ].value = window.innerWidth;
				postprocessing.bokeh_uniforms[ 'textureHeight' ].value = window.innerHeight;
				postprocessing.materialBokeh = new THREE.ShaderMaterial( {
					uniforms: postprocessing.bokeh_uniforms,
					vertexShader: bokeh_shader.vertexShader,
					fragmentShader: bokeh_shader.fragmentShader,
					defines: {
						RINGS: shaderSettings.rings,
						SAMPLES: shaderSettings.samples
					}
			} );

postprocessing.quad = new THREE.Mesh( new THREE.PlaneGeometry( window.innerWidth, window.innerHeight ), postprocessing.materialBokeh );
postprocessing.quad.position.z = - 500;
postprocessing.scene.add( postprocessing.quad );

}
			//initPostprocessing();
			InitUIClick();
			
        </script>
    </body>
</html>