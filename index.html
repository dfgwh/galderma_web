<!DOCTYPE html>
<html lang = "en">
    <head>
        <title>galderma</title>

		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		
        <link type="text/css" rel="stylesheet" href="main.css">
        
        <style>
			a {
				color: #f00;
			}
			.no-pointer-events {
				pointer-events: none;
			}
			.control-disabled {
				color: #888;
				text-decoration: line-through;
			}
		</style>
    </head>
    <body>
		<script src = "three.js"></script>
        <script src = "js/main.js"></script>

		<div class = "container">
			<div id = "loaderPage">
				<img src="images/GALDERMA_LOGO.svg">
				<div id="progressBar" min="0" max="100"><div id="progress"></div></div>
				<span>Loading...</span>
			</div>
			<div id = "openPackageButton" type = "button">
				<div class = "blockInButton">
					<img src="images/open_icon.svg">
					<span>Open Package</span>
				</div>
			</div>
			<div id = "backButton" type = "button">
				<div class = "blockInButton">
					<img src="images/Vector4.svg">
					<span>Back</span>
				</div>
			</div>
			<div id = "prepareButton" type = "button">
				<div class = "blockInButton">
					<img src="images/prepare_icon.png">
					<span>Prepare</span>
				</div>
			</div>
		</div>

		<script type = "module">

			import { OrbitControls } from './three/examples/jsm/controls/OrbitControls.js';
			//import { TransformControls } from './three/examples/jsm/controls/TransformControls.js'
        	import { FBXLoader } from './three/examples/jsm/loaders/FBXLoader.js';
			import { TWEEN } from './three/examples/jsm/libs/tween.module.min.js';
			import { Reflector } from './three/examples/jsm/objects/Reflector.js';
			import { CSS2DRenderer, CSS2DObject } from './three/examples/jsm/renderers/CSS2DRenderer.js';
			import { Refractor } from './three/examples/jsm/objects/Refractor.js';
			import { WaterRefractionShader } from './three/examples/jsm/shaders/WaterRefractionShader.js';

			// scene field

            let scene, renderer, camera, orbitcontrol;
			let refractor;
			//let transformControls;

			// model field

			let model, mainmodel, ingectionSyringeModel, needle1Model, 
				needle2Model, box, form, manual, formcup, 
				plangerCap, needleCase, needleCap, selectedObject;
			let basePos, baseRot;
			const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(2048)
			const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget)
			const glassMaterial = new THREE.MeshPhysicalMaterial({
				metalness: 1.0,
				roughness: 0.2,
				envMap: cubeRenderTarget.texture,
				refractionRatio: 0.95,
				transparent: true,
				opacity: 0.4,
				transmission: 0.1,
				side: THREE.FrontSide,
				clearcoat: 1.0,
				clearcoatRoughness: 0.39
			});

			const formMaterial = new THREE.MeshPhysicalMaterial({
				metalness: 1.0,
				roughness: 0.2,
				envMap: cubeRenderTarget.texture,
				refractionRatio: 0.95,
				transparent: true,
				opacity: 0.2,
				transmission: 0.1,
				side: THREE.FrontSide,
				clearcoat: 1.0,
				clearcoatRoughness: 0.39
			});

			// animation field

			let skeleton, mixer, clock;
			let scene_action;
			let isOpenPackageAnimate = false, isPrepareAnimate = false, isAnimate = false;
			let timer_delta;
			let isTime = false;
			let tempTime;
			let timedelta = 0;
			let isRebase = false;
			let openPackageAnimationTime = 8.2;
			let prepareAnimationTime = 2.499;

			// ui

			let progressBar;

			// app field

			const container = document.querySelector( '.container' );
			let width = window.innerWidth;
			let height = window.innerHeight;
			var mesh = [];
			let stepindeex = 0;
			let mouse = {
				'position' : {'x' : 0, 'y' : 0},
				'speed' : {'x' : 0, 'y' : 0}
			};
			let my_touch = {
				'start_position' : {'x' : 0, 'y' : 0},
				'position' : {'x' : 0, 'y' : 0}
			}
			let isMouseDown = false;



			init();
			


			function init() {

				progressBar = document.getElementById("progress");

				createScene();		
				scene.add(cubeCamera)

				const fbxLoader = new FBXLoader()
				model = fbxLoader.load(
					'models/Restlane1.fbx',
					(root) => {
						root.scale.set(60, 60, 60)
						scene.add(root);
						console.log(dumpObject(root).join('\n'));
						mainmodel = root;

						skeleton = new THREE.SkeletonHelper( root );
						skeleton.visible = false;
						scene.add( skeleton );

						const clips = root.animations;
						mixer = new THREE.AnimationMixer( root );
						//console.log(clips);


						scene_action = mixer.clipAction(clips[0]);
						//scene_action.play();

						root.traverse(function(child){
							mesh.push(child);
							//console.log(child.name, "    ", child.animations);
							if (child.name == "Box"  /*|| child.name == "Form"*/)
							{
								box = child;
								//box.visible = false;
								//box = null;
							}

							if (child.name == "Injector_t")
							{
								ingectionSyringeModel = child;
							}
							if (child.name == "Needle2_t")
							{
								needle2Model = child;
							}
							if (child.name == "Needle_t")
							{
								needle1Model = child;
							}

                        	if (child.isMesh){

								if (child.name == "Form")
								{
									form = child;
									child.material = formMaterial;
									//child.visible = false;
								}
								if (child.name == "manual")
								{
									manual = child;
								}

								if (child.name == "FormCap")
								{
									formcup = child;
								}
								if (child.name == "plungerCap")
								{
									plangerCap = child;
								}
								
								if (child.name == "NeedleCase")
								{
									needleCase = child;
								}

								if (child.name == "NeedleCap")
								{
									needleCap = child;
								}
                    
								if (child.name == "InjectorGlass" || child.name == "NeedleCap" || child.name == "NeedleCase" || child.name == "NeedleCase2Glass")
								{
									child.material = glassMaterial;

									const annotationDiv = document.createElement('div');
									annotationDiv.className = 'annotationLabel';
									annotationDiv.innerHTML = '25';
									const annotationLabel = new CSS2DObject(annotationDiv);
									annotationLabel.position.copy(child.position);
									root.add(annotationLabel);

										const annotationTextDiv = document.createElement('div');
										annotationTextDiv.className = 'annotationDescription';
										annotationTextDiv.innerHTML = 'child.userData.title';
	
											annotationTextDiv.innerHTML += '<p>' + 'test' + '</p>';
										
										annotationDiv.appendChild(annotationTextDiv);	
								}
							}
                    	});

						document.getElementById('loaderPage').style.display = "none";
						document.getElementById('openPackageButton').style.display = "block";
						update();
					},
					(xhr) => {
						console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
						progressBar.style.width = ((xhr.loaded / xhr.total) * 100)  + "%";
					},
					(error) => {
						console.log(error)
					}
				);

				window.addEventListener('resize', onWindowResize, false)
				
				function onWindowResize() {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					renderer.setSize(window.innerWidth, window.innerHeight)
				}

				function update()
				{
					mixer.update(clock.getDelta());
					requestAnimationFrame(update)
				}

				function animate() {
					//model.rotation.y += 0.1;
					requestAnimationFrame(animate)
					orbitcontrol.update();
					TWEEN.update()
					renderer.render(scene, camera)
				}
				animate();

			}

			// created base configurations for scene
			function createScene()
			{
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 1, 4, - 30 );
				camera.lookAt( 0, 1, 0 );

				document.addEventListener('mousedown', onDocumentMouseDown, false);

				clock = new THREE.Clock();

				scene = new THREE.Scene();
				scene.background = new THREE.Color("rgb(133,202,237)");
				scene.fog = new THREE.Fog("rgb(133,202,237)", 20, 80 );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				container.appendChild( renderer.domElement );

				//OrbitControls
				orbitcontrol = new OrbitControls(camera, renderer.domElement);
				orbitcontrol.update();
				orbitcontrol.maxPolarAngle = Math.PI / 2.5;
				//orbitcontrol.minPolarAngle = Math.PI / 3;
				orbitcontrol.enablePan = false;
				orbitcontrol.dampingFactor = 0.1;
				orbitcontrol.enableDamping = true;
				orbitcontrol.minDistance = 20;
				orbitcontrol.maxDistance = 55;

				/* = new TransformControls(camera, renderer.domElement);
				transformControls.enabled = false;
				transformControls.setMode('rotate');
				scene.add(transformControls);*/

				const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				hemiLight.position.set( 0, 20, 0 );
				scene.add( hemiLight );
				const dirLight = new THREE.DirectionalLight( 0xffffff );
				dirLight.position.set( - 3, 10, - 10 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.top = 2;
				dirLight.shadow.camera.bottom = - 2;
				dirLight.shadow.camera.left = - 2;
				dirLight.shadow.camera.right = 2;
				dirLight.shadow.camera.near = 0.1;
				dirLight.shadow.camera.far = 40;
				scene.add( dirLight );

				// ground
				const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
				mesh.rotation.x = - Math.PI / 2;
				mesh.position.y = -20;
				mesh.receiveShadow = true;
				scene.add( mesh );

				const refractorGeometry = new THREE.PlaneGeometry( 2000, 2000 );

				refractor = new Refractor( refractorGeometry, {
					color: 0x999999,
					textureWidth: 100,
					textureHeight: 100,
					shader: WaterRefractionShader
				} );
				refractor.position.set( 0, 0, -1 );
				refractor.rotation.set(0, - Math.PI , 0);
				scene.add( refractor );
				refractor.visible = false;
			}

			// write object structer to console
			function dumpObject(obj, lines = [], isLast = true, prefix = '') {
					const localPrefix = isLast ? '└─' : '├─';
					lines.push(`${prefix}${prefix ? localPrefix : ''}${obj.name || '*no-name*'} [${obj.type}]`);
					const newPrefix = prefix + (isLast ? '  ' : '│ ');
					const lastNdx = obj.children.length - 1;
					obj.children.forEach((child, ndx) => {
						const isLast = ndx === lastNdx;
						dumpObject(child, lines, isLast, newPrefix);
					});
					return lines;
			}

			function startOpenPackageAnimation()
			{
				timer_delta = openPackageAnimationTime;

				scene_action.reset()
				scene_action.timeScale = 1;
				scene_action.setLoop(THREE.LoopOnce);
				scene_action.clampWhenFinished = true;

				scene_action.play();
				isAnimate = true;
				isOpenPackageAnimate = true;

			}
			
			function endOpenPackageAnimation()
			{
				startSecondStep();
			}

			function reversOpenPackageAnimation()
			{
				timer_delta = openPackageAnimationTime;//6.6 + 1.6;

				scene_action.time = openPackageAnimationTime;
				scene_action.paused = false;
				scene_action.timeScale = -1;
				scene_action.setLoop(THREE.LoopOnce);  



				isAnimate = true;
				isOpenPackageAnimate = true;
				isRebase = true;

				manual.visible = false;
				formcup.visible = false;
				box.visible = false;
				form.visible = false;
			}

			function startPrepareAnimation()
			{
				timer_delta = prepareAnimationTime;

				//scene_action.reset()
				scene_action.time = openPackageAnimationTime;
				scene_action.timeScale = 1;
				scene_action.setLoop(THREE.LoopOnce);
				scene_action.clampWhenFinished = true;
				

				scene_action.paused = false;

				needle2Model.visible = false;
				plangerCap.visible = false;
				needleCase.visible = false;
				needleCap.visible = false;

				isAnimate = true;
				isPrepareAnimate = true;

				document.getElementById("prepareButton").style.display = "none";
				document.getElementById("backButton").style.display = "none";
			}

			function reversPrepareAnimation()
			{
				timer_delta = prepareAnimationTime;

				scene_action.paused = false;
				scene_action.timeScale = -1;
				scene_action.setLoop(THREE.LoopOnce); 

				isAnimate = true;
				isPrepareAnimate = true;

				scene_action.paused=false;

				//document.getElementById("prepareButton").style.display = "none";
				document.getElementById("backButton").style.display = "none";
			}

			function endReversPrepareAnimation()
			{
				needle2Model.visible = true;
				plangerCap.visible = true;
				needleCase.visible = true;
				needleCap.visible = true;

				isRebase = false;

				startSecondStep();
			}

			function endPrepareAnimation()
			{
				document.getElementById("backButton").style.display = "block";
				stepindeex = 2;
				orbitcontrol.enabled = true;
			}

			function startSecondStep()
			{
				document.getElementById("backButton").style.display = "block";
				document.getElementById("prepareButton").style.display = "block";
				stepindeex = 1;
			}


			function resizeRendererToDisplaySize(renderer) {
				const canvas = renderer.domElement;
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				const needResize = canvas.width !== width || canvas.height !== height;
				if (needResize) {
				renderer.setSize(width, height, false);
				}
				return needResize;
			}



			function render(time) {
				time *= 0.001;  // convert to seconds
				if (isAnimate && !isTime)
				{
					isTime = true;
					tempTime = time;
					//console.log("start", time, " ", timer_delta);
				}

				if (isTime)
				{
					timedelta = (time) - tempTime;
				}
				//timedelta = (time)- tempTime;

				if (isAnimate&&isOpenPackageAnimate)
				{
					if (isRebase)
					{
						
						console.log(timedelta);
						if (timedelta > 1.5 && !formcup.visible)
						{
							box.visible = true;
							form.visible = true;
							manual.visible = true
							formcup.visible = true;
						}
						if (timedelta > timer_delta)
						{
							isAnimate = false;
							isTime = false;
							isOpenPackageAnimate = false;
							isRebase = false;

							scene_action.paused = true;
							orbitcontrol.enabled = true;
							
							document.getElementById("openPackageButton").style.display = "block";
						}
					}
					else
					{
						if (timedelta > 3.6 && formcup.visible)
						{
							form.visible = false;
							formcup.visible = false;
						}

						if (timedelta > 6.625 && manual.visible)
						{
							box.visible = false;
							manual.visible = false;
						}

						if (timedelta > timer_delta)
						{
							isAnimate = false;
							isTime = false;
							isOpenPackageAnimate = false;

							scene_action.paused = true;

							endOpenPackageAnimation();
						}
					}
				}

				if (isAnimate&&isPrepareAnimate)
				{
					//console.log(timedelta)
					if (isRebase)
					{
						/*if (timedelta > 0.89 && !isPrepareInjectorAnimate)
						{
							isPrepareInjectorAnimate = true;
							prepareinjector_action.play();
							console.log("start moov injectro")
						}*/
						if (timedelta > timer_delta)
						{
							isAnimate = false;
							isTime = false;
							isPrepareAnimate = false;

							scene_action.paused = true;

							endReversPrepareAnimation();
						}
					}
					else{

						/*if (timedelta > 1.6 && isPrepareInjectorAnimate)
						{
							isPrepareInjectorAnimate = false;
							prepareinjector_action.paused = true;
							console.log("end moov injectro")
						}*/
						if (timedelta > timer_delta)
						{
							isAnimate = false;
							isTime = false;
							isPrepareAnimate = false;

							scene_action.paused = true;

							endPrepareAnimation();
						}
					}

				}

	
				renderer.render(scene, camera);
				
				requestAnimationFrame(render);
			}
			requestAnimationFrame(render);

			function setMainDefaultPosition()
			{
				camera.position.set( 1, 4, - 30 );
				mainmodel.rotation.set(0,0,0);
				mainmodel.position.set(0,0,0);
			}

			function InitUIClick()
			{
				let obj = document.getElementById("openPackageButton");
				let backButton = document.getElementById("backButton");
				let prepareButton = document.getElementById("prepareButton");

				obj.onclick = function(){

					setMainDefaultPosition();
					orbitcontrol.enabled = false;
					startOpenPackageAnimation();
					obj.style.display = "none";
					//backButton.style.display = "block";
				}

				backButton.onclick = function(){
					
					setMainDefaultPosition();
					orbitcontrol.enabled = false;
					if (stepindeex == '2')
					{
						isRebase = true;
						reversPrepareAnimation();
					}
					if (stepindeex == '1')
					{
						isRebase = true;
						backButton.style.display = "none";
						prepareButton.style.display = "none";
						reversOpenPackageAnimation();
						stepindeex = 0;
					}
					if (stepindeex == '3' || stepindeex == '4' || stepindeex == '5')
					{
						backButton.style.display = "none";
						//transformControls.enabled = false;
						//transformControls.visible = false;
						selectedObject.rotation.x = baseRot.x;
						selectedObject.rotation.y = baseRot.y;
						selectedObject.rotation.z = baseRot.z;
						animateVector3(selectedObject.position, basePos, {
							duration: 2000, 
							easing : TWEEN.Easing.Quadratic.InOut,
							update: function(d) {
								console.log("Updating: " + d);
							},
							callback : function(){
								console.log("Completed");
								refractor.visible = false;
								startSecondStep();
							}
						});
					}
				}
				prepareButton.onclick = function(){
					startPrepareAnimation();
				}


			}


			document.addEventListener('click', onDocumentMouseDown, false);
	
			function onDocumentMouseDown(event) {
				// Click on the screen to create a vector
				var vector = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window
					.innerHeight) * 2 + 1, 0.5);
					vector = vector.unproject (camera); // convert the coordinates of the screen into the coordinate of the three-dimensional scene
				var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
				var intersects = raycaster.intersectObjects(mesh, true);

				if (stepindeex == '1')
				{
					if (intersects.length > 0) {
						//intersects[0].object.material.color.set("#ff0000");
						intersects.forEach(element => {
							//console.log(element.object.name);
							if ((element.object.name == "Injector" ||
							element.object.name == "InjectorGlass" ||
							element.object.name == "plungerCap" ||
							element.object.name == "InjectorPlunger")
							&&stepindeex=='1')
							{
								//console.log("injector");
								stepindeex = 3;
								mooveSelectedObjAction(ingectionSyringeModel);
								return;
							}
							if ((element.object.name == "Needle" ||
							element.object.name == "NeedleCase" ||
							element.object.name == "NeedleCap")
							&&stepindeex=='1')
							{
								//console.log("needle1");
								stepindeex = 4;
								mooveSelectedObjAction(needle1Model);
								return;
							}
							if ((element.object.name == "NeedleCase2" ||
							element.object.name == "NeedleCase2Glass")
							&&stepindeex=='1')
							{
								//console.log("needle2");
								stepindeex = 5;
								mooveSelectedObjAction(needle2Model);
								return;
							}	
						});
					}
				}	
			}

			function mooveSelectedObjAction(obj)
			{
				document.getElementById("prepareButton").style.display = "none";
				document.getElementById("backButton").style.display = "none";

				refractor.visible = true;
				//console.log(obj.rotation);
				var target = (stepindeex=='5')?(new THREE.Vector3(0, 0, -0.1)):(new THREE.Vector3(0, 0.05, 0));
				//console.log(obj.position);
				basePos = new THREE.Vector3();
				basePos.x = obj.position.x;
				basePos.y = obj.position.y;
				basePos.z = obj.position.z;
				baseRot = new THREE.Vector3();
				baseRot.x = obj.rotation.x;
				baseRot.y = obj.rotation.y;
				baseRot.z = obj.rotation.z;
				selectedObject = obj;
				animateVector3(selectedObject.position, target, {
					duration: 2000, 
					easing : TWEEN.Easing.Quadratic.InOut,
					update: function(d) {
						//console.log("Updating: " + d);
					},
					callback : function(){
						//console.log("Completed");
						document.getElementById("backButton").style.display = "block";
						//transformControls.attach(selectedObject);
						//transformControls.enabled = true;
						//transformControls.visible = true;

					}
				});
			}
			function animateVector3(vectorToAnimate, target, options){
				//console.log(vectorToAnimate, " to ", target);
				options = options || {};
				// get targets from options or set to defaults
				var to = target || THREE.Vector3(),
					easing = options.easing || TWEEN.Easing.Quadratic.In,
					duration = options.duration || 2000;
				// create the tween
				var tweenVector3 = new TWEEN.Tween(vectorToAnimate)
					.to({ x: to.x, y: to.y, z: to.z, }, duration)
					.easing(easing)
					.onUpdate(function(d) {
						if(options.update){ 
							options.update(d);
						}
					})
					.onComplete(function(){
					if(options.callback) options.callback();
					});
				// start the tween
				tweenVector3.start();
				// return the tween in case we want to manipulate it later on
				return tweenVector3;
			}

			window.addEventListener('contextmenu', (e) => {
				e.preventDefault();
			})

			window.addEventListener('mousedown', (e) => {
				e.preventDefault();
				isMouseDown = true;
				//console.log(e);
			});

			window.addEventListener('mouseup', (e) => {
				e.preventDefault();
				isMouseDown = false;
				//console.log(e);
			});
			
			window.addEventListener('mousemove', (e) => {
				//console.log(e);
				if (isMouseDown && (stepindeex == '3' || stepindeex == '4' || stepindeex == '5'))
				{
					mouse.position.x = e.screenX;
					mouse.position.y = e.screenY;
					mouse.speed.x = e.movementX;
					mouse.speed.y = e.movementY;
					moove(mouse);
				}
			});

			function moove(mouse) {
				if (selectedObject)
				{
					//selectedObject.rotateY(-mouse.speed.y * 0.005);
					//selectedObject.rotateZ(-mouse.speed.x * 0.005);
					selectedObject.rotateX(mouse.speed.x * 0.005);
				}
			}

			//var src = document.getElementById("source");

			/*document.addEventListener('touchstart', function(e) {
				// Iterate through the touch points and log each screenX/Y coordinate.
				// The unit of each coordinate is CSS pixels.
				var i;
				for (i=0; i < e.touches.length; i++) {
					console.log("touchpoint[" + i + "].screenX = " + e.touches[i].screenX);
					console.log("touchpoint[" + i + "].screenY = " + e.touches[i].screenY);
				}
			}, false);*/

			var el = document.getElementById("canvas");
			container.addEventListener("touchstart", function(e) {
				//isMouseDown = true;
				//console.log("start touch")
				my_touch.start_position.x = e.touches[0].pageX;
				my_touch.start_position.y = e.touches[0].pageY;
			}, false);
			container.addEventListener("touchend", function(e) {
				//isMouseDown = false;
			}, false);
			container.addEventListener("touchcancel", function(e) {
				//isMouseDown = false;
			}, false);
			container.addEventListener("touchmove", function(e) {
				if (stepindeex == '3' || stepindeex == '4' || stepindeex == '5')
				{
					my_touch.position.x = e.touches[0].pageX;
					my_touch.position.y = e.touches[0].pageY;
					//console.log(my_touch.start_position," ",my_touch.position);
					moove_mobile(my_touch);
					//handleMove(e);
				}
			}, false);

			function moove_mobile(touch){
				if (touch.position.x > touch.start_position.x)
				{
					selectedObject.rotation.y += 0.1
				}
				else if (touch.position.x < touch.start_position.x)
				{
					selectedObject.rotation.y -= 0.1
				}
				touch.start_position.x = touch.position.x;
				touch.start_position.y = touch.position.y;
			}

			function handleMove(evt) {
				evt.preventDefault();
				var el = document.getElementById("canvas");
				var ctx = el.getContext("2d");
				var touches = evt.changedTouches;

				for (var i = 0; i < touches.length; i++) {
					var color = colorForTouch(touches[i]);
					var idx = ongoingTouchIndexById(touches[i].identifier);

					if (idx >= 0) {
					//console.log("continuing touch "+idx);
					ctx.beginPath();
					//console.log("ctx.moveTo(" + ongoingTouches[idx].pageX + ", " + ongoingTouches[idx].pageY + ");");
					ctx.moveTo(ongoingTouches[idx].pageX, ongoingTouches[idx].pageY);
					//console.log("ctx.lineTo(" + touches[i].pageX + ", " + touches[i].pageY + ");");
					ctx.lineTo(touches[i].pageX, touches[i].pageY);
					ctx.lineWidth = 4;
					ctx.strokeStyle = color;
					ctx.stroke();

					ongoingTouches.splice(idx, 1, copyTouch(touches[i]));  // swap in the new touch record
					//console.log(".");
					} else {
					//console.log("can't figure out which touch to continue");
					}
				}
				}

			InitUIClick();
			
        </script>
    </body>
</html>